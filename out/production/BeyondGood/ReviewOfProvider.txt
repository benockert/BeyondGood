Review of Provider’s Code
Design Critique
The provider’s code was overall designed well, but had some flaws. One thing we noticed was that their code was very tightly coupled. Classes often relied on other classes as functionality was piled onto a single class or spread too thin across many classes. We had to ask the providers multiple times to make their code more loosely coupled. For example, some of their classes took in their spreadsheet model implementation as a field rather than taking in the spreadsheet model interface. This made it difficult for us to write adapters for their classes and interfaces, as we were, at first, unable to adapt our model to their model implementation (we can’t implement classes).

Implementation Critique
Overall, we were able to understand our provider’s code and implementation enough to make their editor view work with our code. We particularly appreciated how they created a custom, informative exception class for an invalid formula, and threw those instead of generic illegal argument exceptions, as well as how they made visual distinctions between reference errors and value errors (REF! vs VALUE!). However, we also found some limitations within their implementation. For example, they did not use a non-mutable model within their visual view, which could leak implementation details and allow the view to directly mutate the mode. Furthermore, they also created multiple parsers in addition to the sexp parser given to us, such as their ReadCoord class that parses a Coord. This made it difficult to understand their code at times, and also required us to ask for addition implementation details.

Documentation Critique
The providers of our code documented every interface, class, and method they sent us. Each method and class was properly commented and formatted. However, there were limitations of their documentation. For example, documentation in the IFormulaVisitor class that was provided to us was often vague. @return types would say “the output of the visitor” or just “some type”, which was unhelpful to us when determining what the visitor did. We also found a few times where objects were not named specifically enough, such as an ArrayList named “arraylist”. 
The providers also gave us a README file, however it was extremely general and gave us no information as to how their interfaces interact with each other. Likewise, it did not give us a good overview of the functionalities, design, structure, or UI of their code. Overall, making the documentation more complete and detailed would have better helped us understand the provider’s code. 

Design/Code Limitations & Suggestions
We recognized the following limitations within the provider’s code and design:
	- The code was overall too tightly coupled. 	- The documentation was overall vague and limiting. 	- The view has direct mutable access to the model. 	- Use of additional parsers.  
To help solve these limitations, we suggest the following:
	- Ensure that each method takes an interface instead of a class when needed. 	- Ensure that classes are not taking on too much functionality, or that one function is not being spread too thin across multiple classes. 	- Read over documentation and add more detail. 	- Construct a read-only model that can be passed to the views and controller as needed. 	- Try and optimize your code such that additional parsers are not needed (especially with regards to the Coord class).
